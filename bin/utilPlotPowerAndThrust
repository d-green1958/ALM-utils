#!/usr/bin/env python3

import os
import sys
import argparse
import matplotlib.pyplot as plt
import numpy as np


sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from src import turbineOutput
from src import plot
from src import analysis





def main():
    parser = argparse.ArgumentParser(description='Plot streamwise force distribution.')
    parser.add_argument('directory', nargs='?', default=os.getcwd(),
                        help='Optional directory path to plot residuals for (default: current directory)')
    parser.add_argument('-timeSeries', action='store_true', default=False,
                    help='Flag to indicate if time series should be plotted (default: False)')
    parser.add_argument('-convergence', action='store_true', default=False,
                        help='Flag to indicate if convergence should be checked (default: False)')
    parser.add_argument('-startTime', type=float, default=None,
                        help='Start time for plotting (default: None)')
    parser.add_argument('-endTime', type=float, default=None,
                        help='End time for plotting (default: None)')
    parser.add_argument('-lastPeriod', action='store_true', default=False,
                        help='Flag to indicate to plot the last rotation period (default: False)')
    parser.add_argument('-lastNPeriods', type=float, default=None,
                        help='Flag to plot the last N periods (default: None)')

    args = parser.parse_args()
    
    # check case directory exists
    dir_path = os.path.abspath(args.directory)
    if not os.path.isdir(dir_path):
        print(f"Directory '{dir_path}' is not valid!")
        sys.exit(1)
        
    plot_something = False
    if args.timeSeries or args.convergence:
        plot_something = True
    else:
        print("no method flags (-timeSeries, -PSD, -convergence) provided")
        sys.exit(1)
    
    data = turbineOutput.read_file(dir_path, ['powerRotor','thrust', "turbineArrayProperties"])
    times, power_and_torque_data = turbineOutput.process_power_and_thrust(data)
    
    
    # adjust the start and end times accordingly
    time_limit_set = False
    if args.startTime != None:
        time_limit_set = True
    
    if args.endTime != None:
        time_limit_set = True
        
    if args.lastPeriod:
        if time_limit_set:
            print("cannot set a time limit (start/end) and use lastPeriod")
            sys.exit(1)
        
        rotor_rpm = data["turbineArrayProperties"]["turbine0"]["RotSpeed"]
        rotor_time_period = 2*np.pi/rotor_rpm
        
        print(f"rotor time period is {rotor_time_period}")
        final_time = times[-1]
        inds, nearest_time = analysis.find_nearest_time(final_time - rotor_time_period, times)
        args.startTime = nearest_time
        args.endTime = final_time
        
    if args.lastNPeriods != None:
        if time_limit_set:
            print("cannot set a time limit (start/end) and use lastPeriod")
            sys.exit(1)
        
        rotor_rpm = data["turbineArrayProperties"]["turbine0"]["RotSpeed"]
        rotor_time_period = 2*np.pi/rotor_rpm
        
        print(f"rotor time period is {rotor_time_period}")
        final_time = times[-1]
        inds, nearest_time = analysis.find_nearest_time(final_time - rotor_time_period * args.lastNPeriods, times)
        args.startTime = nearest_time
        args.endTime = final_time
    
    
    ## now plot for the different methods
    if args.timeSeries:
        plot.plot_power_and_thrust_time_series(power_and_torque_data, args.startTime, args.endTime)
    if args.convergence:
        plot.plot_power_and_thrust_convergence(power_and_torque_data, args.startTime, args.endTime)
    plt.show()
    
    
    
    

if __name__ == "__main__":
    main()