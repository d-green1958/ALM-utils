#!/usr/bin/env python3

import numpy as np
import matplotlib.pyplot as plt
import sys
import os
import pandas as pd
import argparse

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from src import turbineOutput
        
def process_radius(data):
    keys = data.keys()
    if "radiusC" not in keys:
        print("radiusC not found in data")
        sys.exit(1)
    
    rad_data = data["radiusC"]
    
    # get number of rotors
    rotor_ids = np.unique(rad_data[:,0])
    if len(rotor_ids) != 1:
        print("number of rotors != 1")
        sys.exit(1)
    
    # get number of blades
    blade_ids = np.unique(rad_data[:,1])
    if len(blade_ids) != 3:
        print("number of blades != 3 [not implemented, may cause issues]")
        sys.exit(1)
    
    # check for symmetry of rotor
    radial_pos = rad_data[:,2::]
    if (radial_pos[0].any() != radial_pos[1].any()) or (radial_pos[1].any() != radial_pos[2].any()):
        print("rotor is assymetric [not implemented]")
        sys.exit(1)
    
    return radial_pos[0]

def process_spanwise_forces(data, keys):
    forces = {}
    times_defined = False
    for key in keys:
        if key not in data.keys():
            print(f"{key} not in data")
            sys.exit(1)
            
        force_data = data[key]
        if len(np.unique(force_data[:,0])) != 1:
            print("number of rotors != 1 [not implemented]")
            sys.exit(1)
        if len(np.unique(force_data[:,1])) != 3:
            print("number of blades != 3 [not implemented]")
            sys.exit(1)
        
        blade_forces = [] # [blade number][time step][position on blade]
        if times_defined == True:
            if times.any() != np.unique(force_data[:,2]).any():
                print("inconsistent times between force keys")
                sys.exit(1)
        
        times = np.unique(force_data[:,2])
        times_defined = True
        blade_ids = np.unique(force_data[:,1])
        
        for blade_id in blade_ids:
            inds = (force_data[:,1] == blade_id)
            temp = force_data[inds,4::]
            blade_forces.append(temp)
        
        forces[key] = blade_forces
        forces["times"] = times
                    
    return times, forces
        
def plot_instantaneous_spanwise_forces(radial_pos, times, forces, plot_time):
    number_of_keys = len(forces.keys())
    if "times" in forces.keys():
        number_of_keys -= 1
    
    # find the index of the target time
    difs = times - [plot_time]*len(times)
    abs_difs = abs(difs)
    min_value = min(abs_difs)
    inds = [i for i, x in enumerate(abs_difs) if x == min_value]
    time_index = inds[0]
    nearest_time = times[inds[0]]
    if nearest_time != plot_time:
        print(f'trying to plot at {plot_time}s', end= ' ')
        print(f'--> nearest time is {times[time_index]}s [timestep: {time_index}]')
        plot_time = nearest_time
    else:
        print(f"plotting at time {plot_time}s")
    
    # normalise the radial distances
    num_points = len(radial_pos)
    radial_pos = [float(val) for val in radial_pos]
    max_rad = max(radial_pos)
    radial_pos_normalised = [((val)/max_rad) for val in radial_pos] 
    
    # find distances between points
    element_length = np.zeros(num_points)
    element_length[0] = radial_pos[1]-radial_pos[0]
    element_length[-1] = radial_pos[-1]-radial_pos[-2]
    for index, elem in enumerate(radial_pos):
        if (index>=1 and index < num_points-1):
            element_length[index] = (radial_pos[index+1]-radial_pos[index])
    
    
    # create the subplots
    fig, axs = plt.subplots(1,number_of_keys)
    plot_counter = 0
    
    for key in forces.keys():
        if key == "times":
            continue
        force_data = forces[key]
        for blade_id in range(len(force_data)):
            force = force_data[blade_id][time_index]
            
            force_per_length = force/element_length            
            axs[plot_counter].plot(radial_pos_normalised, force_per_length, label=f"blade {blade_id}")
            
        axs[plot_counter].set_title(key)
        axs[plot_counter].grid(True)
        axs[plot_counter].set_ylabel("Force [N]")
        axs[plot_counter].set_xlabel("r/R")
        axs[plot_counter].legend()
            
        plot_counter += 1
    
    fig.suptitle(f"Spanwise forces at t={plot_time}s")
    fig.tight_layout()
              
        
    
    
    
def main():
    parser = argparse.ArgumentParser(description='Plot streamwise force distribution.')
    parser.add_argument('directory', nargs='?', default=os.getcwd(),
                        help='Optional directory path to plot residuals for (default: current directory)')
    parser.add_argument('-instantTime', type=float, help='Plot at some time.')
    parser.add_argument('-latestTime', action='store_true',help='Flag to plot at the latest time.')
    args = parser.parse_args()
    
    plot_something = False
    if args.latestTime:
        print("plotting final time")
        plot_something = True
    
    if args.instantTime is not None:
        print(f"Instant time: {args.instantTime}")
        plot_something = True
        
    if plot_something == False:
        print("no flags given")
        sys.exit(1)
    
    # check case directory exists
    dir_path = os.path.abspath(args.directory)
    if not os.path.isdir(dir_path):
        print(f"Directory '{dir_path}' is not valid!")
        sys.exit(1)

    data = turbineOutput.read_file(dir_path, ["axialForce", "tangentialForce", "radiusC"])
    radial_pos = turbineOutput.process_radius(data)
    times, forces = turbineOutput.process_spanwise_forces(data, ["axialForce", "tangentialForce"])
        
    if args.latestTime:
        plot_instantaneous_spanwise_forces(radial_pos, times, forces, times[-1])
    
    if args.instantTime is not None:
        plot_instantaneous_spanwise_forces(radial_pos, times, forces, args.instantTime)
    
    
    plt.show()
    
    return

if __name__ == "__main__":
    main()    
