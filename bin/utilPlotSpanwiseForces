#!/usr/bin/env python3

import numpy as np
import matplotlib.pyplot as plt
import sys
import os
import pandas as pd
import argparse

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from src import turbineOutput
        
def plot_instantaneous_spanwise_forces(radial_pos, times, forces, plot_time):
    number_of_keys = len(forces.keys())
    if "times" in forces.keys():
        number_of_keys -= 1
    
    # find the index of the target time
    difs = times - [plot_time]*len(times)
    abs_difs = abs(difs)
    min_value = min(abs_difs)
    inds = [i for i, x in enumerate(abs_difs) if x == min_value]
    time_index = inds[0]
    nearest_time = times[inds[0]]
    if nearest_time != plot_time:
        print(f'trying to plot at {plot_time}s', end= ' ')
        print(f'--> nearest time is {times[time_index]}s [timestep: {time_index}]')
        plot_time = nearest_time
    else:
        print(f"plotting at time {plot_time}s")
    
    # normalise the radial distances
    num_points = len(radial_pos)
    radial_pos = [float(val) for val in radial_pos]
    max_rad = max(radial_pos)
    radial_pos_normalised = [((val)/max_rad) for val in radial_pos] 
    
    # find distances between points
    element_length = np.zeros(num_points)
    element_length[0] = radial_pos[1]-radial_pos[0]
    element_length[-1] = radial_pos[-1]-radial_pos[-2]
    for index, elem in enumerate(radial_pos):
        if (index>=1 and index < num_points-1):
            element_length[index] = (radial_pos[index+1]-radial_pos[index])
    
    
    # create the subplots
    fig, axs = plt.subplots(1,number_of_keys)
    plot_counter = 0
    
    for key in forces.keys():
        if key == "times":
            continue
        force_data = forces[key]
        for blade_id in range(len(force_data)):
            force = force_data[blade_id][time_index]
            
            force_per_length = force/element_length            
            axs[plot_counter].plot(radial_pos_normalised, force_per_length, label=f"blade {blade_id}")
            
        axs[plot_counter].set_title(key)
        axs[plot_counter].grid(True)
        axs[plot_counter].set_ylabel("Force [N]")
        axs[plot_counter].set_xlabel("r/R")
        axs[plot_counter].legend()
            
        plot_counter += 1
    
    fig.suptitle(f"Spanwise forces at t={plot_time}s")
    fig.tight_layout()
              
        
def main():
    parser = argparse.ArgumentParser(description='Plot streamwise force distribution.')
    parser.add_argument('directory', nargs='?', default=os.getcwd(),
                        help='Optional directory path to plot residuals for (default: current directory)')
    parser.add_argument('-instantTime', type=float, help='Plot at some time.')
    parser.add_argument('-latestTime', action='store_true',help='Flag to plot at the latest time.')
    args = parser.parse_args()
    
    plot_something = False
    if args.latestTime:
        print("plotting final time")
        plot_something = True
    
    if args.instantTime is not None:
        print(f"Instant time: {args.instantTime}")
        plot_something = True
        
    if plot_something == False:
        print("no flags given")
        sys.exit(1)
    
    # check case directory exists
    dir_path = os.path.abspath(args.directory)
    if not os.path.isdir(dir_path):
        print(f"Directory '{dir_path}' is not valid!")
        sys.exit(1)

    data = turbineOutput.read_file(dir_path, ["axialForce", "tangentialForce", "radiusC"])
    radial_pos = turbineOutput.process_radius(data)
    times, forces = turbineOutput.process_spanwise_forces(data, ["axialForce", "tangentialForce"])
        
    if args.latestTime:
        plot_instantaneous_spanwise_forces(radial_pos, times, forces, times[-1])
    
    if args.instantTime is not None:
        plot_instantaneous_spanwise_forces(radial_pos, times, forces, args.instantTime)
    
    
    plt.show()
    
    return

if __name__ == "__main__":
    main()    
